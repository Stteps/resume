{"version":3,"file":"js/630.bfc1a2a8.js","mappings":"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","sources":["webpack://resume/../node_modules/@babel/runtime/helpers/esm/typeof.js","webpack://resume/../node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js","webpack://resume/../node_modules/@babel/runtime/helpers/esm/slicedToArray.js","webpack://resume/../node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js","webpack://resume/../node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js","webpack://resume/../node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js","webpack://resume/../node_modules/@babel/runtime/helpers/esm/nonIterableRest.js","webpack://resume/../node_modules/react/index.js","webpack://resume/../node_modules/iobuffer/lib-esm/text.js","webpack://resume/../node_modules/iobuffer/lib-esm/IOBuffer.js"],"sourcesContent":["function _typeof(o) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) {\n    return typeof o;\n  } : function (o) {\n    return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n  }, _typeof(o);\n}\nexport { _typeof as default };","function _arrayLikeToArray(r, a) {\n  (null == a || a > r.length) && (a = r.length);\n  for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];\n  return n;\n}\nexport { _arrayLikeToArray as default };","import arrayWithHoles from \"./arrayWithHoles.js\";\nimport iterableToArrayLimit from \"./iterableToArrayLimit.js\";\nimport unsupportedIterableToArray from \"./unsupportedIterableToArray.js\";\nimport nonIterableRest from \"./nonIterableRest.js\";\nfunction _slicedToArray(r, e) {\n  return arrayWithHoles(r) || iterableToArrayLimit(r, e) || unsupportedIterableToArray(r, e) || nonIterableRest();\n}\nexport { _slicedToArray as default };","function _arrayWithHoles(r) {\n  if (Array.isArray(r)) return r;\n}\nexport { _arrayWithHoles as default };","function _iterableToArrayLimit(r, l) {\n  var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"];\n  if (null != t) {\n    var e,\n      n,\n      i,\n      u,\n      a = [],\n      f = !0,\n      o = !1;\n    try {\n      if (i = (t = t.call(r)).next, 0 === l) {\n        if (Object(t) !== t) return;\n        f = !1;\n      } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);\n    } catch (r) {\n      o = !0, n = r;\n    } finally {\n      try {\n        if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return;\n      } finally {\n        if (o) throw n;\n      }\n    }\n    return a;\n  }\n}\nexport { _iterableToArrayLimit as default };","import arrayLikeToArray from \"./arrayLikeToArray.js\";\nfunction _unsupportedIterableToArray(r, a) {\n  if (r) {\n    if (\"string\" == typeof r) return arrayLikeToArray(r, a);\n    var t = {}.toString.call(r).slice(8, -1);\n    return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? arrayLikeToArray(r, a) : void 0;\n  }\n}\nexport { _unsupportedIterableToArray as default };","function _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nexport { _nonIterableRest as default };","'use strict';\n\nif (process.env.NODE_ENV === 'production') {\n  module.exports = require('./cjs/react.production.min.js');\n} else {\n  module.exports = require('./cjs/react.development.js');\n}\n","export function decode(bytes, encoding = 'utf8') {\n    const decoder = new TextDecoder(encoding);\n    return decoder.decode(bytes);\n}\nconst encoder = new TextEncoder();\nexport function encode(str) {\n    return encoder.encode(str);\n}\n//# sourceMappingURL=text.js.map","import { decode, encode } from './text';\nconst defaultByteLength = 1024 * 8;\nconst hostBigEndian = (() => {\n    const array = new Uint8Array(4);\n    const view = new Uint32Array(array.buffer);\n    return !((view[0] = 1) & array[0]);\n})();\nconst typedArrays = {\n    int8: globalThis.Int8Array,\n    uint8: globalThis.Uint8Array,\n    int16: globalThis.Int16Array,\n    uint16: globalThis.Uint16Array,\n    int32: globalThis.Int32Array,\n    uint32: globalThis.Uint32Array,\n    uint64: globalThis.BigUint64Array,\n    int64: globalThis.BigInt64Array,\n    float32: globalThis.Float32Array,\n    float64: globalThis.Float64Array,\n};\nexport class IOBuffer {\n    /**\n     * Reference to the internal ArrayBuffer object.\n     */\n    buffer;\n    /**\n     * Byte length of the internal ArrayBuffer.\n     */\n    byteLength;\n    /**\n     * Byte offset of the internal ArrayBuffer.\n     */\n    byteOffset;\n    /**\n     * Byte length of the internal ArrayBuffer.\n     */\n    length;\n    /**\n     * The current offset of the buffer's pointer.\n     */\n    offset;\n    lastWrittenByte;\n    littleEndian;\n    _data;\n    _mark;\n    _marks;\n    /**\n     * Create a new IOBuffer.\n     * @param data - The data to construct the IOBuffer with.\n     * If data is a number, it will be the new buffer's length<br>\n     * If data is `undefined`, the buffer will be initialized with a default length of 8Kb<br>\n     * If data is an ArrayBuffer, SharedArrayBuffer, an ArrayBufferView (Typed Array), an IOBuffer instance,\n     * or a Node.js Buffer, a view will be created over the underlying ArrayBuffer.\n     * @param options - An object for the options.\n     * @returns A new IOBuffer instance.\n     */\n    constructor(data = defaultByteLength, options = {}) {\n        let dataIsGiven = false;\n        if (typeof data === 'number') {\n            data = new ArrayBuffer(data);\n        }\n        else {\n            dataIsGiven = true;\n            this.lastWrittenByte = data.byteLength;\n        }\n        const offset = options.offset ? options.offset >>> 0 : 0;\n        const byteLength = data.byteLength - offset;\n        let dvOffset = offset;\n        if (ArrayBuffer.isView(data) || data instanceof IOBuffer) {\n            if (data.byteLength !== data.buffer.byteLength) {\n                dvOffset = data.byteOffset + offset;\n            }\n            data = data.buffer;\n        }\n        if (dataIsGiven) {\n            this.lastWrittenByte = byteLength;\n        }\n        else {\n            this.lastWrittenByte = 0;\n        }\n        this.buffer = data;\n        this.length = byteLength;\n        this.byteLength = byteLength;\n        this.byteOffset = dvOffset;\n        this.offset = 0;\n        this.littleEndian = true;\n        this._data = new DataView(this.buffer, dvOffset, byteLength);\n        this._mark = 0;\n        this._marks = [];\n    }\n    /**\n     * Checks if the memory allocated to the buffer is sufficient to store more\n     * bytes after the offset.\n     * @param byteLength - The needed memory in bytes.\n     * @returns `true` if there is sufficient space and `false` otherwise.\n     */\n    available(byteLength = 1) {\n        return this.offset + byteLength <= this.length;\n    }\n    /**\n     * Check if little-endian mode is used for reading and writing multi-byte\n     * values.\n     * @returns `true` if little-endian mode is used, `false` otherwise.\n     */\n    isLittleEndian() {\n        return this.littleEndian;\n    }\n    /**\n     * Set little-endian mode for reading and writing multi-byte values.\n     * @returns This.\n     */\n    setLittleEndian() {\n        this.littleEndian = true;\n        return this;\n    }\n    /**\n     * Check if big-endian mode is used for reading and writing multi-byte values.\n     * @returns `true` if big-endian mode is used, `false` otherwise.\n     */\n    isBigEndian() {\n        return !this.littleEndian;\n    }\n    /**\n     * Switches to big-endian mode for reading and writing multi-byte values.\n     * @returns This.\n     */\n    setBigEndian() {\n        this.littleEndian = false;\n        return this;\n    }\n    /**\n     * Move the pointer n bytes forward.\n     * @param n - Number of bytes to skip.\n     * @returns This.\n     */\n    skip(n = 1) {\n        this.offset += n;\n        return this;\n    }\n    /**\n     * Move the pointer n bytes backward.\n     * @param n - Number of bytes to move back.\n     * @returns This.\n     */\n    back(n = 1) {\n        this.offset -= n;\n        return this;\n    }\n    /**\n     * Move the pointer to the given offset.\n     * @param offset - The offset to move to.\n     * @returns This.\n     */\n    seek(offset) {\n        this.offset = offset;\n        return this;\n    }\n    /**\n     * Store the current pointer offset.\n     * @see {@link IOBuffer#reset}\n     * @returns This.\n     */\n    mark() {\n        this._mark = this.offset;\n        return this;\n    }\n    /**\n     * Move the pointer back to the last pointer offset set by mark.\n     * @see {@link IOBuffer#mark}\n     * @returns This.\n     */\n    reset() {\n        this.offset = this._mark;\n        return this;\n    }\n    /**\n     * Push the current pointer offset to the mark stack.\n     * @see {@link IOBuffer#popMark}\n     * @returns This.\n     */\n    pushMark() {\n        this._marks.push(this.offset);\n        return this;\n    }\n    /**\n     * Pop the last pointer offset from the mark stack, and set the current\n     * pointer offset to the popped value.\n     * @see {@link IOBuffer#pushMark}\n     * @returns This.\n     */\n    popMark() {\n        const offset = this._marks.pop();\n        if (offset === undefined) {\n            throw new Error('Mark stack empty');\n        }\n        this.seek(offset);\n        return this;\n    }\n    /**\n     * Move the pointer offset back to 0.\n     * @returns This.\n     */\n    rewind() {\n        this.offset = 0;\n        return this;\n    }\n    /**\n     * Make sure the buffer has sufficient memory to write a given byteLength at\n     * the current pointer offset.\n     * If the buffer's memory is insufficient, this method will create a new\n     * buffer (a copy) with a length that is twice (byteLength + current offset).\n     * @param byteLength - The needed memory in bytes.\n     * @returns This.\n     */\n    ensureAvailable(byteLength = 1) {\n        if (!this.available(byteLength)) {\n            const lengthNeeded = this.offset + byteLength;\n            const newLength = lengthNeeded * 2;\n            const newArray = new Uint8Array(newLength);\n            newArray.set(new Uint8Array(this.buffer));\n            this.buffer = newArray.buffer;\n            this.length = newLength;\n            this.byteLength = newLength;\n            this._data = new DataView(this.buffer);\n        }\n        return this;\n    }\n    /**\n     * Read a byte and return false if the byte's value is 0, or true otherwise.\n     * Moves pointer forward by one byte.\n     * @returns The read boolean.\n     */\n    readBoolean() {\n        return this.readUint8() !== 0;\n    }\n    /**\n     * Read a signed 8-bit integer and move pointer forward by 1 byte.\n     * @returns The read byte.\n     */\n    readInt8() {\n        return this._data.getInt8(this.offset++);\n    }\n    /**\n     * Read an unsigned 8-bit integer and move pointer forward by 1 byte.\n     * @returns The read byte.\n     */\n    readUint8() {\n        return this._data.getUint8(this.offset++);\n    }\n    /**\n     * Alias for {@link IOBuffer#readUint8}.\n     * @returns The read byte.\n     */\n    readByte() {\n        return this.readUint8();\n    }\n    /**\n     * Read `n` bytes and move pointer forward by `n` bytes.\n     * @param n - Number of bytes to read.\n     * @returns The read bytes.\n     */\n    readBytes(n = 1) {\n        return this.readArray(n, 'uint8');\n    }\n    /**\n     * Creates an array of corresponding to the type `type` and size `size`.\n     * For example type `uint8` will create a `Uint8Array`.\n     * @param size - size of the resulting array\n     * @param type - number type of elements to read\n     * @returns The read array.\n     */\n    readArray(size, type) {\n        const bytes = typedArrays[type].BYTES_PER_ELEMENT * size;\n        const offset = this.byteOffset + this.offset;\n        const slice = this.buffer.slice(offset, offset + bytes);\n        if (this.littleEndian === hostBigEndian &&\n            type !== 'uint8' &&\n            type !== 'int8') {\n            const slice = new Uint8Array(this.buffer.slice(offset, offset + bytes));\n            slice.reverse();\n            const returnArray = new typedArrays[type](slice.buffer);\n            this.offset += bytes;\n            returnArray.reverse();\n            return returnArray;\n        }\n        const returnArray = new typedArrays[type](slice);\n        this.offset += bytes;\n        return returnArray;\n    }\n    /**\n     * Read a 16-bit signed integer and move pointer forward by 2 bytes.\n     * @returns The read value.\n     */\n    readInt16() {\n        const value = this._data.getInt16(this.offset, this.littleEndian);\n        this.offset += 2;\n        return value;\n    }\n    /**\n     * Read a 16-bit unsigned integer and move pointer forward by 2 bytes.\n     * @returns The read value.\n     */\n    readUint16() {\n        const value = this._data.getUint16(this.offset, this.littleEndian);\n        this.offset += 2;\n        return value;\n    }\n    /**\n     * Read a 32-bit signed integer and move pointer forward by 4 bytes.\n     * @returns The read value.\n     */\n    readInt32() {\n        const value = this._data.getInt32(this.offset, this.littleEndian);\n        this.offset += 4;\n        return value;\n    }\n    /**\n     * Read a 32-bit unsigned integer and move pointer forward by 4 bytes.\n     * @returns The read value.\n     */\n    readUint32() {\n        const value = this._data.getUint32(this.offset, this.littleEndian);\n        this.offset += 4;\n        return value;\n    }\n    /**\n     * Read a 32-bit floating number and move pointer forward by 4 bytes.\n     * @returns The read value.\n     */\n    readFloat32() {\n        const value = this._data.getFloat32(this.offset, this.littleEndian);\n        this.offset += 4;\n        return value;\n    }\n    /**\n     * Read a 64-bit floating number and move pointer forward by 8 bytes.\n     * @returns The read value.\n     */\n    readFloat64() {\n        const value = this._data.getFloat64(this.offset, this.littleEndian);\n        this.offset += 8;\n        return value;\n    }\n    /**\n     * Read a 64-bit signed integer number and move pointer forward by 8 bytes.\n     * @returns The read value.\n     */\n    readBigInt64() {\n        const value = this._data.getBigInt64(this.offset, this.littleEndian);\n        this.offset += 8;\n        return value;\n    }\n    /**\n     * Read a 64-bit unsigned integer number and move pointer forward by 8 bytes.\n     * @returns The read value.\n     */\n    readBigUint64() {\n        const value = this._data.getBigUint64(this.offset, this.littleEndian);\n        this.offset += 8;\n        return value;\n    }\n    /**\n     * Read a 1-byte ASCII character and move pointer forward by 1 byte.\n     * @returns The read character.\n     */\n    readChar() {\n        // eslint-disable-next-line unicorn/prefer-code-point\n        return String.fromCharCode(this.readInt8());\n    }\n    /**\n     * Read `n` 1-byte ASCII characters and move pointer forward by `n` bytes.\n     * @param n - Number of characters to read.\n     * @returns The read characters.\n     */\n    readChars(n = 1) {\n        let result = '';\n        for (let i = 0; i < n; i++) {\n            result += this.readChar();\n        }\n        return result;\n    }\n    /**\n     * Read the next `n` bytes, return a UTF-8 decoded string and move pointer\n     * forward by `n` bytes.\n     * @param n - Number of bytes to read.\n     * @returns The decoded string.\n     */\n    readUtf8(n = 1) {\n        return decode(this.readBytes(n));\n    }\n    /**\n     * Read the next `n` bytes, return a string decoded with `encoding` and move pointer\n     * forward by `n` bytes.\n     * If no encoding is passed, the function is equivalent to @see {@link IOBuffer#readUtf8}\n     * @param n - Number of bytes to read.\n     * @param encoding - The encoding to use. Default is 'utf8'.\n     * @returns The decoded string.\n     */\n    decodeText(n = 1, encoding = 'utf8') {\n        return decode(this.readBytes(n), encoding);\n    }\n    /**\n     * Write 0xff if the passed value is truthy, 0x00 otherwise and move pointer\n     * forward by 1 byte.\n     * @param value - The value to write.\n     * @returns This.\n     */\n    writeBoolean(value) {\n        this.writeUint8(value ? 0xff : 0x00);\n        return this;\n    }\n    /**\n     * Write `value` as an 8-bit signed integer and move pointer forward by 1 byte.\n     * @param value - The value to write.\n     * @returns This.\n     */\n    writeInt8(value) {\n        this.ensureAvailable(1);\n        this._data.setInt8(this.offset++, value);\n        this._updateLastWrittenByte();\n        return this;\n    }\n    /**\n     * Write `value` as an 8-bit unsigned integer and move pointer forward by 1\n     * byte.\n     * @param value - The value to write.\n     * @returns This.\n     */\n    writeUint8(value) {\n        this.ensureAvailable(1);\n        this._data.setUint8(this.offset++, value);\n        this._updateLastWrittenByte();\n        return this;\n    }\n    /**\n     * An alias for {@link IOBuffer#writeUint8}.\n     * @param value - The value to write.\n     * @returns This.\n     */\n    writeByte(value) {\n        return this.writeUint8(value);\n    }\n    /**\n     * Write all elements of `bytes` as uint8 values and move pointer forward by\n     * `bytes.length` bytes.\n     * @param bytes - The array of bytes to write.\n     * @returns This.\n     */\n    writeBytes(bytes) {\n        this.ensureAvailable(bytes.length);\n        // eslint-disable-next-line @typescript-eslint/prefer-for-of\n        for (let i = 0; i < bytes.length; i++) {\n            this._data.setUint8(this.offset++, bytes[i]);\n        }\n        this._updateLastWrittenByte();\n        return this;\n    }\n    /**\n     * Write `value` as a 16-bit signed integer and move pointer forward by 2\n     * bytes.\n     * @param value - The value to write.\n     * @returns This.\n     */\n    writeInt16(value) {\n        this.ensureAvailable(2);\n        this._data.setInt16(this.offset, value, this.littleEndian);\n        this.offset += 2;\n        this._updateLastWrittenByte();\n        return this;\n    }\n    /**\n     * Write `value` as a 16-bit unsigned integer and move pointer forward by 2\n     * bytes.\n     * @param value - The value to write.\n     * @returns This.\n     */\n    writeUint16(value) {\n        this.ensureAvailable(2);\n        this._data.setUint16(this.offset, value, this.littleEndian);\n        this.offset += 2;\n        this._updateLastWrittenByte();\n        return this;\n    }\n    /**\n     * Write `value` as a 32-bit signed integer and move pointer forward by 4\n     * bytes.\n     * @param value - The value to write.\n     * @returns This.\n     */\n    writeInt32(value) {\n        this.ensureAvailable(4);\n        this._data.setInt32(this.offset, value, this.littleEndian);\n        this.offset += 4;\n        this._updateLastWrittenByte();\n        return this;\n    }\n    /**\n     * Write `value` as a 32-bit unsigned integer and move pointer forward by 4\n     * bytes.\n     * @param value - The value to write.\n     * @returns This.\n     */\n    writeUint32(value) {\n        this.ensureAvailable(4);\n        this._data.setUint32(this.offset, value, this.littleEndian);\n        this.offset += 4;\n        this._updateLastWrittenByte();\n        return this;\n    }\n    /**\n     * Write `value` as a 32-bit floating number and move pointer forward by 4\n     * bytes.\n     * @param value - The value to write.\n     * @returns This.\n     */\n    writeFloat32(value) {\n        this.ensureAvailable(4);\n        this._data.setFloat32(this.offset, value, this.littleEndian);\n        this.offset += 4;\n        this._updateLastWrittenByte();\n        return this;\n    }\n    /**\n     * Write `value` as a 64-bit floating number and move pointer forward by 8\n     * bytes.\n     * @param value - The value to write.\n     * @returns This.\n     */\n    writeFloat64(value) {\n        this.ensureAvailable(8);\n        this._data.setFloat64(this.offset, value, this.littleEndian);\n        this.offset += 8;\n        this._updateLastWrittenByte();\n        return this;\n    }\n    /**\n     * Write `value` as a 64-bit signed bigint and move pointer forward by 8\n     * bytes.\n     * @param value - The value to write.\n     * @returns This.\n     */\n    writeBigInt64(value) {\n        this.ensureAvailable(8);\n        this._data.setBigInt64(this.offset, value, this.littleEndian);\n        this.offset += 8;\n        this._updateLastWrittenByte();\n        return this;\n    }\n    /**\n     * Write `value` as a 64-bit unsigned bigint and move pointer forward by 8\n     * bytes.\n     * @param value - The value to write.\n     * @returns This.\n     */\n    writeBigUint64(value) {\n        this.ensureAvailable(8);\n        this._data.setBigUint64(this.offset, value, this.littleEndian);\n        this.offset += 8;\n        this._updateLastWrittenByte();\n        return this;\n    }\n    /**\n     * Write the charCode of `str`'s first character as an 8-bit unsigned integer\n     * and move pointer forward by 1 byte.\n     * @param str - The character to write.\n     * @returns This.\n     */\n    writeChar(str) {\n        // eslint-disable-next-line unicorn/prefer-code-point\n        return this.writeUint8(str.charCodeAt(0));\n    }\n    /**\n     * Write the charCodes of all `str`'s characters as 8-bit unsigned integers\n     * and move pointer forward by `str.length` bytes.\n     * @param str - The characters to write.\n     * @returns This.\n     */\n    writeChars(str) {\n        for (let i = 0; i < str.length; i++) {\n            // eslint-disable-next-line unicorn/prefer-code-point\n            this.writeUint8(str.charCodeAt(i));\n        }\n        return this;\n    }\n    /**\n     * UTF-8 encode and write `str` to the current pointer offset and move pointer\n     * forward according to the encoded length.\n     * @param str - The string to write.\n     * @returns This.\n     */\n    writeUtf8(str) {\n        return this.writeBytes(encode(str));\n    }\n    /**\n     * Export a Uint8Array view of the internal buffer.\n     * The view starts at the byte offset and its length\n     * is calculated to stop at the last written byte or the original length.\n     * @returns A new Uint8Array view.\n     */\n    toArray() {\n        return new Uint8Array(this.buffer, this.byteOffset, this.lastWrittenByte);\n    }\n    /**\n     *  Get the total number of bytes written so far, regardless of the current offset.\n     * @returns - Total number of bytes.\n     */\n    getWrittenByteLength() {\n        return this.lastWrittenByte - this.byteOffset;\n    }\n    /**\n     * Update the last written byte offset\n     * @private\n     */\n    _updateLastWrittenByte() {\n        if (this.offset > this.lastWrittenByte) {\n            this.lastWrittenByte = this.offset;\n        }\n    }\n}\n//# sourceMappingURL=IOBuffer.js.map"],"names":["_typeof","o","Symbol","iterator","constructor","prototype","_arrayLikeToArray","r","a","length","e","n","Array","_slicedToArray","isArray","l","t","i","u","f","call","next","Object","done","push","value","toString","slice","name","from","test","TypeError","module","exports","decode","bytes","encoding","TextDecoder","encoder","TextEncoder","hostBigEndian","array","Uint8Array","Uint32Array","buffer","typedArrays","int8","globalThis","Int8Array","uint8","int16","Int16Array","uint16","Uint16Array","int32","Int32Array","uint32","uint64","BigUint64Array","int64","BigInt64Array","float32","Float32Array","float64","Float64Array","IOBuffer","byteLength","byteOffset","offset","lastWrittenByte","littleEndian","_data","_mark","_marks","data","options","dataIsGiven","ArrayBuffer","this","dvOffset","isView","DataView","available","isLittleEndian","setLittleEndian","isBigEndian","setBigEndian","skip","back","seek","mark","reset","pushMark","popMark","pop","undefined","Error","rewind","ensureAvailable","newLength","newArray","set","readBoolean","readUint8","readInt8","getInt8","getUint8","readByte","readBytes","readArray","size","type","BYTES_PER_ELEMENT","reverse","returnArray","readInt16","getInt16","readUint16","getUint16","readInt32","getInt32","readUint32","getUint32","readFloat32","getFloat32","readFloat64","getFloat64","readBigInt64","getBigInt64","readBigUint64","getBigUint64","readChar","String","fromCharCode","readChars","result","readUtf8","decodeText","writeBoolean","writeUint8","writeInt8","setInt8","_updateLastWrittenByte","setUint8","writeByte","writeBytes","writeInt16","setInt16","writeUint16","setUint16","writeInt32","setInt32","writeUint32","setUint32","writeFloat32","setFloat32","writeFloat64","setFloat64","writeBigInt64","setBigInt64","writeBigUint64","setBigUint64","writeChar","str","charCodeAt","writeChars","writeUtf8","encode","toArray","getWrittenByteLength"],"ignoreList":[],"sourceRoot":""}