{"version":3,"file":"js/npm.fast-png.cc14e7e2.js","mappings":"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","sources":["webpack://resume/../node_modules/fast-png/lib-esm/helpers/crc.js","webpack://resume/../node_modules/fast-png/lib-esm/helpers/unfilter.js","webpack://resume/../node_modules/fast-png/lib-esm/helpers/applyUnfilter.js","webpack://resume/../node_modules/fast-png/lib-esm/helpers/decodeInterlaceAdam7.js","webpack://resume/../node_modules/fast-png/lib-esm/helpers/decodeInterlaceNull.js","webpack://resume/../node_modules/fast-png/lib-esm/helpers/signature.js","webpack://resume/../node_modules/fast-png/lib-esm/helpers/text.js","webpack://resume/../node_modules/fast-png/lib-esm/PngDecoder.js","webpack://resume/../node_modules/fast-png/lib-esm/internalTypes.js","webpack://resume/../node_modules/fast-png/lib-esm/types.js","webpack://resume/../node_modules/fast-png/lib-esm/index.js","webpack://resume/../node_modules/fast-png/lib-esm/PngEncoder.js"],"sourcesContent":["const crcTable = [];\nfor (let n = 0; n < 256; n++) {\n    let c = n;\n    for (let k = 0; k < 8; k++) {\n        if (c & 1) {\n            c = 0xedb88320 ^ (c >>> 1);\n        }\n        else {\n            c = c >>> 1;\n        }\n    }\n    crcTable[n] = c;\n}\nconst initialCrc = 0xffffffff;\nfunction updateCrc(currentCrc, data, length) {\n    let c = currentCrc;\n    for (let n = 0; n < length; n++) {\n        c = crcTable[(c ^ data[n]) & 0xff] ^ (c >>> 8);\n    }\n    return c;\n}\nfunction crc(data, length) {\n    return (updateCrc(initialCrc, data, length) ^ initialCrc) >>> 0;\n}\nexport function checkCrc(buffer, crcLength, chunkName) {\n    const expectedCrc = buffer.readUint32();\n    const actualCrc = crc(new Uint8Array(buffer.buffer, buffer.byteOffset + buffer.offset - crcLength - 4, crcLength), crcLength); // \"- 4\" because we already advanced by reading the CRC\n    if (actualCrc !== expectedCrc) {\n        throw new Error(`CRC mismatch for chunk ${chunkName}. Expected ${expectedCrc}, found ${actualCrc}`);\n    }\n}\nexport function writeCrc(buffer, length) {\n    buffer.writeUint32(crc(new Uint8Array(buffer.buffer, buffer.byteOffset + buffer.offset - length, length), length));\n}\n//# sourceMappingURL=crc.js.map","export function unfilterNone(currentLine, newLine, bytesPerLine) {\n    for (let i = 0; i < bytesPerLine; i++) {\n        newLine[i] = currentLine[i];\n    }\n}\nexport function unfilterSub(currentLine, newLine, bytesPerLine, bytesPerPixel) {\n    let i = 0;\n    for (; i < bytesPerPixel; i++) {\n        // just copy first bytes\n        newLine[i] = currentLine[i];\n    }\n    for (; i < bytesPerLine; i++) {\n        newLine[i] = (currentLine[i] + newLine[i - bytesPerPixel]) & 0xff;\n    }\n}\nexport function unfilterUp(currentLine, newLine, prevLine, bytesPerLine) {\n    let i = 0;\n    if (prevLine.length === 0) {\n        // just copy bytes for first line\n        for (; i < bytesPerLine; i++) {\n            newLine[i] = currentLine[i];\n        }\n    }\n    else {\n        for (; i < bytesPerLine; i++) {\n            newLine[i] = (currentLine[i] + prevLine[i]) & 0xff;\n        }\n    }\n}\nexport function unfilterAverage(currentLine, newLine, prevLine, bytesPerLine, bytesPerPixel) {\n    let i = 0;\n    if (prevLine.length === 0) {\n        for (; i < bytesPerPixel; i++) {\n            newLine[i] = currentLine[i];\n        }\n        for (; i < bytesPerLine; i++) {\n            newLine[i] = (currentLine[i] + (newLine[i - bytesPerPixel] >> 1)) & 0xff;\n        }\n    }\n    else {\n        for (; i < bytesPerPixel; i++) {\n            newLine[i] = (currentLine[i] + (prevLine[i] >> 1)) & 0xff;\n        }\n        for (; i < bytesPerLine; i++) {\n            newLine[i] =\n                (currentLine[i] + ((newLine[i - bytesPerPixel] + prevLine[i]) >> 1)) &\n                    0xff;\n        }\n    }\n}\nexport function unfilterPaeth(currentLine, newLine, prevLine, bytesPerLine, bytesPerPixel) {\n    let i = 0;\n    if (prevLine.length === 0) {\n        for (; i < bytesPerPixel; i++) {\n            newLine[i] = currentLine[i];\n        }\n        for (; i < bytesPerLine; i++) {\n            newLine[i] = (currentLine[i] + newLine[i - bytesPerPixel]) & 0xff;\n        }\n    }\n    else {\n        for (; i < bytesPerPixel; i++) {\n            newLine[i] = (currentLine[i] + prevLine[i]) & 0xff;\n        }\n        for (; i < bytesPerLine; i++) {\n            newLine[i] =\n                (currentLine[i] +\n                    paethPredictor(newLine[i - bytesPerPixel], prevLine[i], prevLine[i - bytesPerPixel])) &\n                    0xff;\n        }\n    }\n}\nfunction paethPredictor(a, b, c) {\n    const p = a + b - c;\n    const pa = Math.abs(p - a);\n    const pb = Math.abs(p - b);\n    const pc = Math.abs(p - c);\n    if (pa <= pb && pa <= pc)\n        return a;\n    else if (pb <= pc)\n        return b;\n    else\n        return c;\n}\n//# sourceMappingURL=unfilter.js.map","import { unfilterAverage, unfilterNone, unfilterPaeth, unfilterSub, unfilterUp, } from './unfilter';\n/**\n * Apllies filter on scanline based on the filter type.\n * @param filterType - The filter type to apply.\n * @param currentLine - The current line of pixel data.\n * @param newLine - The new line of pixel data.\n * @param prevLine - The previous line of pixel data.\n * @param passLineBytes - The number of bytes in the pass line.\n * @param bytesPerPixel - The number of bytes per pixel.\n */\nexport function applyUnfilter(filterType, currentLine, newLine, prevLine, passLineBytes, bytesPerPixel) {\n    switch (filterType) {\n        case 0:\n            unfilterNone(currentLine, newLine, passLineBytes);\n            break;\n        case 1:\n            unfilterSub(currentLine, newLine, passLineBytes, bytesPerPixel);\n            break;\n        case 2:\n            unfilterUp(currentLine, newLine, prevLine, passLineBytes);\n            break;\n        case 3:\n            unfilterAverage(currentLine, newLine, prevLine, passLineBytes, bytesPerPixel);\n            break;\n        case 4:\n            unfilterPaeth(currentLine, newLine, prevLine, passLineBytes, bytesPerPixel);\n            break;\n        default:\n            throw new Error(`Unsupported filter: ${filterType}`);\n    }\n}\n//# sourceMappingURL=applyUnfilter.js.map","import { applyUnfilter } from './applyUnfilter';\nconst uint16 = new Uint16Array([0x00ff]);\nconst uint8 = new Uint8Array(uint16.buffer);\nconst osIsLittleEndian = uint8[0] === 0xff;\n/**\n * Decodes the Adam7 interlaced PNG data.\n *\n * @param params - DecodeInterlaceNullParams\n * @returns - array of pixel data.\n */\nexport function decodeInterlaceAdam7(params) {\n    const { data, width, height, channels, depth } = params;\n    // Adam7 interlacing pattern\n    const passes = [\n        { x: 0, y: 0, xStep: 8, yStep: 8 }, // Pass 1\n        { x: 4, y: 0, xStep: 8, yStep: 8 }, // Pass 2\n        { x: 0, y: 4, xStep: 4, yStep: 8 }, // Pass 3\n        { x: 2, y: 0, xStep: 4, yStep: 4 }, // Pass 4\n        { x: 0, y: 2, xStep: 2, yStep: 4 }, // Pass 5\n        { x: 1, y: 0, xStep: 2, yStep: 2 }, // Pass 6\n        { x: 0, y: 1, xStep: 1, yStep: 2 }, // Pass 7\n    ];\n    const bytesPerPixel = Math.ceil(depth / 8) * channels;\n    const resultData = new Uint8Array(height * width * bytesPerPixel);\n    let offset = 0;\n    // Process each pass\n    for (let passIndex = 0; passIndex < 7; passIndex++) {\n        const pass = passes[passIndex];\n        // Calculate pass dimensions\n        const passWidth = Math.ceil((width - pass.x) / pass.xStep);\n        const passHeight = Math.ceil((height - pass.y) / pass.yStep);\n        if (passWidth <= 0 || passHeight <= 0)\n            continue;\n        const passLineBytes = passWidth * bytesPerPixel;\n        const prevLine = new Uint8Array(passLineBytes);\n        // Process each scanline in this pass\n        for (let y = 0; y < passHeight; y++) {\n            // First byte is the filter type\n            const filterType = data[offset++];\n            const currentLine = data.subarray(offset, offset + passLineBytes);\n            offset += passLineBytes;\n            // Create a new line for the unfiltered data\n            const newLine = new Uint8Array(passLineBytes);\n            // Apply the appropriate unfilter\n            applyUnfilter(filterType, currentLine, newLine, prevLine, passLineBytes, bytesPerPixel);\n            prevLine.set(newLine);\n            for (let x = 0; x < passWidth; x++) {\n                const outputX = pass.x + x * pass.xStep;\n                const outputY = pass.y + y * pass.yStep;\n                if (outputX >= width || outputY >= height)\n                    continue;\n                for (let i = 0; i < bytesPerPixel; i++) {\n                    resultData[(outputY * width + outputX) * bytesPerPixel + i] =\n                        newLine[x * bytesPerPixel + i];\n                }\n            }\n        }\n    }\n    if (depth === 16) {\n        const uint16Data = new Uint16Array(resultData.buffer);\n        if (osIsLittleEndian) {\n            for (let k = 0; k < uint16Data.length; k++) {\n                // PNG is always big endian. Swap the bytes.\n                uint16Data[k] = swap16(uint16Data[k]);\n            }\n        }\n        return uint16Data;\n    }\n    else {\n        return resultData;\n    }\n}\nfunction swap16(val) {\n    return ((val & 0xff) << 8) | ((val >> 8) & 0xff);\n}\n//# sourceMappingURL=decodeInterlaceAdam7.js.map","import { unfilterAverage, unfilterNone, unfilterPaeth, unfilterSub, unfilterUp, } from './unfilter';\nconst uint16 = new Uint16Array([0x00ff]);\nconst uint8 = new Uint8Array(uint16.buffer);\nconst osIsLittleEndian = uint8[0] === 0xff;\nconst empty = new Uint8Array(0);\nexport function decodeInterlaceNull(params) {\n    const { data, width, height, channels, depth } = params;\n    const bytesPerPixel = Math.ceil(depth / 8) * channels;\n    const bytesPerLine = Math.ceil((depth / 8) * channels * width);\n    const newData = new Uint8Array(height * bytesPerLine);\n    let prevLine = empty;\n    let offset = 0;\n    let currentLine;\n    let newLine;\n    for (let i = 0; i < height; i++) {\n        currentLine = data.subarray(offset + 1, offset + 1 + bytesPerLine);\n        newLine = newData.subarray(i * bytesPerLine, (i + 1) * bytesPerLine);\n        switch (data[offset]) {\n            case 0:\n                unfilterNone(currentLine, newLine, bytesPerLine);\n                break;\n            case 1:\n                unfilterSub(currentLine, newLine, bytesPerLine, bytesPerPixel);\n                break;\n            case 2:\n                unfilterUp(currentLine, newLine, prevLine, bytesPerLine);\n                break;\n            case 3:\n                unfilterAverage(currentLine, newLine, prevLine, bytesPerLine, bytesPerPixel);\n                break;\n            case 4:\n                unfilterPaeth(currentLine, newLine, prevLine, bytesPerLine, bytesPerPixel);\n                break;\n            default:\n                throw new Error(`Unsupported filter: ${data[offset]}`);\n        }\n        prevLine = newLine;\n        offset += bytesPerLine + 1;\n    }\n    if (depth === 16) {\n        const uint16Data = new Uint16Array(newData.buffer);\n        if (osIsLittleEndian) {\n            for (let k = 0; k < uint16Data.length; k++) {\n                // PNG is always big endian. Swap the bytes.\n                uint16Data[k] = swap16(uint16Data[k]);\n            }\n        }\n        return uint16Data;\n    }\n    else {\n        return newData;\n    }\n}\nfunction swap16(val) {\n    return ((val & 0xff) << 8) | ((val >> 8) & 0xff);\n}\n//# sourceMappingURL=decodeInterlaceNull.js.map","// https://www.w3.org/TR/PNG/#5PNG-file-signature\nconst pngSignature = Uint8Array.of(137, 80, 78, 71, 13, 10, 26, 10);\nexport function writeSignature(buffer) {\n    buffer.writeBytes(pngSignature);\n}\nexport function checkSignature(buffer) {\n    if (!hasPngSignature(buffer.readBytes(pngSignature.length))) {\n        throw new Error('wrong PNG signature');\n    }\n}\nexport function hasPngSignature(array) {\n    if (array.length < pngSignature.length) {\n        return false;\n    }\n    for (let i = 0; i < pngSignature.length; i++) {\n        if (array[i] !== pngSignature[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n//# sourceMappingURL=signature.js.map","import { writeCrc } from './crc';\n// https://www.w3.org/TR/png/#11tEXt\nexport const textChunkName = 'tEXt';\nconst NULL = 0;\nconst latin1Decoder = new TextDecoder('latin1');\nfunction validateKeyword(keyword) {\n    validateLatin1(keyword);\n    if (keyword.length === 0 || keyword.length > 79) {\n        throw new Error('keyword length must be between 1 and 79');\n    }\n}\n// eslint-disable-next-line no-control-regex\nconst latin1Regex = /^[\\u0000-\\u00FF]*$/;\nfunction validateLatin1(text) {\n    if (!latin1Regex.test(text)) {\n        throw new Error('invalid latin1 text');\n    }\n}\nexport function decodetEXt(text, buffer, length) {\n    const keyword = readKeyword(buffer);\n    text[keyword] = readLatin1(buffer, length - keyword.length - 1);\n}\nexport function encodetEXt(buffer, keyword, text) {\n    validateKeyword(keyword);\n    validateLatin1(text);\n    const length = keyword.length + 1 /* NULL */ + text.length;\n    buffer.writeUint32(length);\n    buffer.writeChars(textChunkName);\n    buffer.writeChars(keyword);\n    buffer.writeByte(NULL);\n    buffer.writeChars(text);\n    writeCrc(buffer, length + 4);\n}\n// https://www.w3.org/TR/png/#11keywords\nexport function readKeyword(buffer) {\n    buffer.mark();\n    while (buffer.readByte() !== NULL) {\n        /* advance */\n    }\n    const end = buffer.offset;\n    buffer.reset();\n    const keyword = latin1Decoder.decode(buffer.readBytes(end - buffer.offset - 1));\n    // NULL\n    buffer.skip(1);\n    validateKeyword(keyword);\n    return keyword;\n}\nexport function readLatin1(buffer, length) {\n    return latin1Decoder.decode(buffer.readBytes(length));\n}\n//# sourceMappingURL=text.js.map","import { IOBuffer } from 'iobuffer';\nimport { inflate, Inflate as Inflator } from 'pako';\nimport { checkCrc } from './helpers/crc';\nimport { decodeInterlaceAdam7 } from './helpers/decodeInterlaceAdam7';\nimport { decodeInterlaceNull } from './helpers/decodeInterlaceNull';\nimport { checkSignature } from './helpers/signature';\nimport { decodetEXt, readKeyword, textChunkName } from './helpers/text';\nimport { ColorType, CompressionMethod, DisposeOpType, FilterMethod, InterlaceMethod, BlendOpType, } from './internalTypes';\nexport default class PngDecoder extends IOBuffer {\n    _checkCrc;\n    _inflator;\n    _png;\n    _apng;\n    _end;\n    _hasPalette;\n    _palette;\n    _hasTransparency;\n    _transparency;\n    _compressionMethod;\n    _filterMethod;\n    _interlaceMethod;\n    _colorType;\n    _isAnimated;\n    _numberOfFrames;\n    _numberOfPlays;\n    _frames;\n    _writingDataChunks;\n    constructor(data, options = {}) {\n        super(data);\n        const { checkCrc = false } = options;\n        this._checkCrc = checkCrc;\n        this._inflator = new Inflator();\n        this._png = {\n            width: -1,\n            height: -1,\n            channels: -1,\n            data: new Uint8Array(0),\n            depth: 1,\n            text: {},\n        };\n        this._apng = {\n            width: -1,\n            height: -1,\n            channels: -1,\n            depth: 1,\n            numberOfFrames: 1,\n            numberOfPlays: 0,\n            text: {},\n            frames: [],\n        };\n        this._end = false;\n        this._hasPalette = false;\n        this._palette = [];\n        this._hasTransparency = false;\n        this._transparency = new Uint16Array(0);\n        this._compressionMethod = CompressionMethod.UNKNOWN;\n        this._filterMethod = FilterMethod.UNKNOWN;\n        this._interlaceMethod = InterlaceMethod.UNKNOWN;\n        this._colorType = ColorType.UNKNOWN;\n        this._isAnimated = false;\n        this._numberOfFrames = 1;\n        this._numberOfPlays = 0;\n        this._frames = [];\n        this._writingDataChunks = false;\n        // PNG is always big endian\n        // https://www.w3.org/TR/PNG/#7Integers-and-byte-order\n        this.setBigEndian();\n    }\n    decode() {\n        checkSignature(this);\n        while (!this._end) {\n            const length = this.readUint32();\n            const type = this.readChars(4);\n            this.decodeChunk(length, type);\n        }\n        this.decodeImage();\n        return this._png;\n    }\n    decodeApng() {\n        checkSignature(this);\n        while (!this._end) {\n            const length = this.readUint32();\n            const type = this.readChars(4);\n            this.decodeApngChunk(length, type);\n        }\n        this.decodeApngImage();\n        return this._apng;\n    }\n    // https://www.w3.org/TR/PNG/#5Chunk-layout\n    decodeChunk(length, type) {\n        const offset = this.offset;\n        switch (type) {\n            // 11.2 Critical chunks\n            case 'IHDR': // 11.2.2 IHDR Image header\n                this.decodeIHDR();\n                break;\n            case 'PLTE': // 11.2.3 PLTE Palette\n                this.decodePLTE(length);\n                break;\n            case 'IDAT': // 11.2.4 IDAT Image data\n                this.decodeIDAT(length);\n                break;\n            case 'IEND': // 11.2.5 IEND Image trailer\n                this._end = true;\n                break;\n            // 11.3 Ancillary chunks\n            case 'tRNS': // 11.3.2.1 tRNS Transparency\n                this.decodetRNS(length);\n                break;\n            case 'iCCP': // 11.3.3.3 iCCP Embedded ICC profile\n                this.decodeiCCP(length);\n                break;\n            case textChunkName: // 11.3.4.3 tEXt Textual data\n                decodetEXt(this._png.text, this, length);\n                break;\n            case 'pHYs': // 11.3.5.3 pHYs Physical pixel dimensions\n                this.decodepHYs();\n                break;\n            default:\n                this.skip(length);\n                break;\n        }\n        if (this.offset - offset !== length) {\n            throw new Error(`Length mismatch while decoding chunk ${type}`);\n        }\n        if (this._checkCrc) {\n            checkCrc(this, length + 4, type);\n        }\n        else {\n            this.skip(4);\n        }\n    }\n    decodeApngChunk(length, type) {\n        const offset = this.offset;\n        if (type !== 'fdAT' && type !== 'IDAT' && this._writingDataChunks) {\n            this.pushDataToFrame();\n        }\n        switch (type) {\n            case 'acTL':\n                this.decodeACTL();\n                break;\n            case 'fcTL':\n                this.decodeFCTL();\n                break;\n            case 'fdAT':\n                this.decodeFDAT(length);\n                break;\n            default:\n                this.decodeChunk(length, type);\n                this.offset = offset + length;\n                break;\n        }\n        if (this.offset - offset !== length) {\n            throw new Error(`Length mismatch while decoding chunk ${type}`);\n        }\n        if (this._checkCrc) {\n            checkCrc(this, length + 4, type);\n        }\n        else {\n            this.skip(4);\n        }\n    }\n    // https://www.w3.org/TR/PNG/#11IHDR\n    decodeIHDR() {\n        const image = this._png;\n        image.width = this.readUint32();\n        image.height = this.readUint32();\n        image.depth = checkBitDepth(this.readUint8());\n        const colorType = this.readUint8();\n        this._colorType = colorType;\n        let channels;\n        switch (colorType) {\n            case ColorType.GREYSCALE:\n                channels = 1;\n                break;\n            case ColorType.TRUECOLOUR:\n                channels = 3;\n                break;\n            case ColorType.INDEXED_COLOUR:\n                channels = 1;\n                break;\n            case ColorType.GREYSCALE_ALPHA:\n                channels = 2;\n                break;\n            case ColorType.TRUECOLOUR_ALPHA:\n                channels = 4;\n                break;\n            // Kept for exhaustiveness.\n            // eslint-disable-next-line unicorn/no-useless-switch-case\n            case ColorType.UNKNOWN:\n            default:\n                throw new Error(`Unknown color type: ${colorType}`);\n        }\n        this._png.channels = channels;\n        this._compressionMethod = this.readUint8();\n        if (this._compressionMethod !== CompressionMethod.DEFLATE) {\n            throw new Error(`Unsupported compression method: ${this._compressionMethod}`);\n        }\n        this._filterMethod = this.readUint8();\n        this._interlaceMethod = this.readUint8();\n    }\n    decodeACTL() {\n        this._numberOfFrames = this.readUint32();\n        this._numberOfPlays = this.readUint32();\n        this._isAnimated = true;\n    }\n    decodeFCTL() {\n        const image = {\n            sequenceNumber: this.readUint32(),\n            width: this.readUint32(),\n            height: this.readUint32(),\n            xOffset: this.readUint32(),\n            yOffset: this.readUint32(),\n            delayNumber: this.readUint16(),\n            delayDenominator: this.readUint16(),\n            disposeOp: this.readUint8(),\n            blendOp: this.readUint8(),\n            data: new Uint8Array(0),\n        };\n        this._frames.push(image);\n    }\n    // https://www.w3.org/TR/PNG/#11PLTE\n    decodePLTE(length) {\n        if (length % 3 !== 0) {\n            throw new RangeError(`PLTE field length must be a multiple of 3. Got ${length}`);\n        }\n        const l = length / 3;\n        this._hasPalette = true;\n        const palette = [];\n        this._palette = palette;\n        for (let i = 0; i < l; i++) {\n            palette.push([this.readUint8(), this.readUint8(), this.readUint8()]);\n        }\n    }\n    // https://www.w3.org/TR/PNG/#11IDAT\n    decodeIDAT(length) {\n        this._writingDataChunks = true;\n        const dataLength = length;\n        const dataOffset = this.offset + this.byteOffset;\n        this._inflator.push(new Uint8Array(this.buffer, dataOffset, dataLength));\n        if (this._inflator.err) {\n            throw new Error(`Error while decompressing the data: ${this._inflator.err}`);\n        }\n        this.skip(length);\n    }\n    decodeFDAT(length) {\n        this._writingDataChunks = true;\n        let dataLength = length;\n        let dataOffset = this.offset + this.byteOffset;\n        dataOffset += 4;\n        dataLength -= 4;\n        this._inflator.push(new Uint8Array(this.buffer, dataOffset, dataLength));\n        if (this._inflator.err) {\n            throw new Error(`Error while decompressing the data: ${this._inflator.err}`);\n        }\n        this.skip(length);\n    }\n    // https://www.w3.org/TR/PNG/#11tRNS\n    decodetRNS(length) {\n        switch (this._colorType) {\n            case ColorType.GREYSCALE:\n            case ColorType.TRUECOLOUR: {\n                if (length % 2 !== 0) {\n                    throw new RangeError(`tRNS chunk length must be a multiple of 2. Got ${length}`);\n                }\n                if (length / 2 > this._png.width * this._png.height) {\n                    throw new Error(`tRNS chunk contains more alpha values than there are pixels (${length / 2} vs ${this._png.width * this._png.height})`);\n                }\n                this._hasTransparency = true;\n                this._transparency = new Uint16Array(length / 2);\n                for (let i = 0; i < length / 2; i++) {\n                    this._transparency[i] = this.readUint16();\n                }\n                break;\n            }\n            case ColorType.INDEXED_COLOUR: {\n                if (length > this._palette.length) {\n                    throw new Error(`tRNS chunk contains more alpha values than there are palette colors (${length} vs ${this._palette.length})`);\n                }\n                let i = 0;\n                for (; i < length; i++) {\n                    const alpha = this.readByte();\n                    this._palette[i].push(alpha);\n                }\n                for (; i < this._palette.length; i++) {\n                    this._palette[i].push(255);\n                }\n                break;\n            }\n            // Kept for exhaustiveness.\n            /* eslint-disable unicorn/no-useless-switch-case */\n            case ColorType.UNKNOWN:\n            case ColorType.GREYSCALE_ALPHA:\n            case ColorType.TRUECOLOUR_ALPHA:\n            default: {\n                throw new Error(`tRNS chunk is not supported for color type ${this._colorType}`);\n            }\n            /* eslint-enable unicorn/no-useless-switch-case */\n        }\n    }\n    // https://www.w3.org/TR/PNG/#11iCCP\n    decodeiCCP(length) {\n        const name = readKeyword(this);\n        const compressionMethod = this.readUint8();\n        if (compressionMethod !== CompressionMethod.DEFLATE) {\n            throw new Error(`Unsupported iCCP compression method: ${compressionMethod}`);\n        }\n        const compressedProfile = this.readBytes(length - name.length - 2);\n        this._png.iccEmbeddedProfile = {\n            name,\n            profile: inflate(compressedProfile),\n        };\n    }\n    // https://www.w3.org/TR/PNG/#11pHYs\n    decodepHYs() {\n        const ppuX = this.readUint32();\n        const ppuY = this.readUint32();\n        const unitSpecifier = this.readByte();\n        this._png.resolution = { x: ppuX, y: ppuY, unit: unitSpecifier };\n    }\n    decodeApngImage() {\n        this._apng.width = this._png.width;\n        this._apng.height = this._png.height;\n        this._apng.channels = this._png.channels;\n        this._apng.depth = this._png.depth;\n        this._apng.numberOfFrames = this._numberOfFrames;\n        this._apng.numberOfPlays = this._numberOfPlays;\n        this._apng.text = this._png.text;\n        this._apng.resolution = this._png.resolution;\n        for (let i = 0; i < this._numberOfFrames; i++) {\n            const newFrame = {\n                sequenceNumber: this._frames[i].sequenceNumber,\n                delayNumber: this._frames[i].delayNumber,\n                delayDenominator: this._frames[i].delayDenominator,\n                data: this._apng.depth === 8\n                    ? new Uint8Array(this._apng.width * this._apng.height * this._apng.channels)\n                    : new Uint16Array(this._apng.width * this._apng.height * this._apng.channels),\n            };\n            const frame = this._frames.at(i);\n            if (frame) {\n                frame.data = decodeInterlaceNull({\n                    data: frame.data,\n                    width: frame.width,\n                    height: frame.height,\n                    channels: this._apng.channels,\n                    depth: this._apng.depth,\n                });\n                if (this._hasPalette) {\n                    this._apng.palette = this._palette;\n                }\n                if (this._hasTransparency) {\n                    this._apng.transparency = this._transparency;\n                }\n                if (i === 0 ||\n                    (frame.xOffset === 0 &&\n                        frame.yOffset === 0 &&\n                        frame.width === this._png.width &&\n                        frame.height === this._png.height)) {\n                    newFrame.data = frame.data;\n                }\n                else {\n                    const prevFrame = this._apng.frames.at(i - 1);\n                    this.disposeFrame(frame, prevFrame, newFrame);\n                    this.addFrameDataToCanvas(newFrame, frame);\n                }\n                this._apng.frames.push(newFrame);\n            }\n        }\n        return this._apng;\n    }\n    disposeFrame(frame, prevFrame, imageFrame) {\n        switch (frame.disposeOp) {\n            case DisposeOpType.NONE:\n                break;\n            case DisposeOpType.BACKGROUND:\n                for (let row = 0; row < this._png.height; row++) {\n                    for (let col = 0; col < this._png.width; col++) {\n                        const index = (row * frame.width + col) * this._png.channels;\n                        for (let channel = 0; channel < this._png.channels; channel++) {\n                            imageFrame.data[index + channel] = 0;\n                        }\n                    }\n                }\n                break;\n            case DisposeOpType.PREVIOUS:\n                imageFrame.data.set(prevFrame.data);\n                break;\n            default:\n                throw new Error('Unknown disposeOp');\n        }\n    }\n    addFrameDataToCanvas(imageFrame, frame) {\n        const maxValue = 1 << this._png.depth;\n        const calculatePixelIndices = (row, col) => {\n            const index = ((row + frame.yOffset) * this._png.width + frame.xOffset + col) *\n                this._png.channels;\n            const frameIndex = (row * frame.width + col) * this._png.channels;\n            return { index, frameIndex };\n        };\n        switch (frame.blendOp) {\n            case BlendOpType.SOURCE:\n                for (let row = 0; row < frame.height; row++) {\n                    for (let col = 0; col < frame.width; col++) {\n                        const { index, frameIndex } = calculatePixelIndices(row, col);\n                        for (let channel = 0; channel < this._png.channels; channel++) {\n                            imageFrame.data[index + channel] =\n                                frame.data[frameIndex + channel];\n                        }\n                    }\n                }\n                break;\n            // https://www.w3.org/TR/png-3/#13Alpha-channel-processing\n            case BlendOpType.OVER:\n                for (let row = 0; row < frame.height; row++) {\n                    for (let col = 0; col < frame.width; col++) {\n                        const { index, frameIndex } = calculatePixelIndices(row, col);\n                        for (let channel = 0; channel < this._png.channels; channel++) {\n                            const sourceAlpha = frame.data[frameIndex + this._png.channels - 1] / maxValue;\n                            const foregroundValue = channel % (this._png.channels - 1) === 0\n                                ? 1\n                                : frame.data[frameIndex + channel];\n                            const value = Math.floor(sourceAlpha * foregroundValue +\n                                (1 - sourceAlpha) * imageFrame.data[index + channel]);\n                            imageFrame.data[index + channel] += value;\n                        }\n                    }\n                }\n                break;\n            default:\n                throw new Error('Unknown blendOp');\n        }\n    }\n    decodeImage() {\n        if (this._inflator.err) {\n            throw new Error(`Error while decompressing the data: ${this._inflator.err}`);\n        }\n        const data = this._isAnimated\n            ? (this._frames?.at(0)).data\n            : this._inflator.result;\n        if (this._filterMethod !== FilterMethod.ADAPTIVE) {\n            throw new Error(`Filter method ${this._filterMethod} not supported`);\n        }\n        if (this._interlaceMethod === InterlaceMethod.NO_INTERLACE) {\n            this._png.data = decodeInterlaceNull({\n                data: data,\n                width: this._png.width,\n                height: this._png.height,\n                channels: this._png.channels,\n                depth: this._png.depth,\n            });\n        }\n        else if (this._interlaceMethod === InterlaceMethod.ADAM7) {\n            this._png.data = decodeInterlaceAdam7({\n                data: data,\n                width: this._png.width,\n                height: this._png.height,\n                channels: this._png.channels,\n                depth: this._png.depth,\n            });\n        }\n        else {\n            throw new Error(`Interlace method ${this._interlaceMethod} not supported`);\n        }\n        if (this._hasPalette) {\n            this._png.palette = this._palette;\n        }\n        if (this._hasTransparency) {\n            this._png.transparency = this._transparency;\n        }\n    }\n    pushDataToFrame() {\n        const result = this._inflator.result;\n        const lastFrame = this._frames.at(-1);\n        if (lastFrame) {\n            lastFrame.data = result;\n        }\n        else {\n            this._frames.push({\n                sequenceNumber: 0,\n                width: this._png.width,\n                height: this._png.height,\n                xOffset: 0,\n                yOffset: 0,\n                delayNumber: 0,\n                delayDenominator: 0,\n                disposeOp: DisposeOpType.NONE,\n                blendOp: BlendOpType.SOURCE,\n                data: result,\n            });\n        }\n        this._inflator = new Inflator();\n        this._writingDataChunks = false;\n    }\n}\nfunction checkBitDepth(value) {\n    if (value !== 1 &&\n        value !== 2 &&\n        value !== 4 &&\n        value !== 8 &&\n        value !== 16) {\n        throw new Error(`invalid bit depth: ${value}`);\n    }\n    return value;\n}\n//# sourceMappingURL=PngDecoder.js.map","export const ColorType = {\n    UNKNOWN: -1,\n    GREYSCALE: 0,\n    TRUECOLOUR: 2,\n    INDEXED_COLOUR: 3,\n    GREYSCALE_ALPHA: 4,\n    TRUECOLOUR_ALPHA: 6,\n};\nexport const CompressionMethod = {\n    UNKNOWN: -1,\n    DEFLATE: 0,\n};\nexport const FilterMethod = {\n    UNKNOWN: -1,\n    ADAPTIVE: 0,\n};\nexport const InterlaceMethod = {\n    UNKNOWN: -1,\n    NO_INTERLACE: 0,\n    ADAM7: 1,\n};\nexport const DisposeOpType = {\n    NONE: 0,\n    BACKGROUND: 1,\n    PREVIOUS: 2,\n};\nexport const BlendOpType = {\n    SOURCE: 0,\n    OVER: 1,\n};\n//# sourceMappingURL=internalTypes.js.map","export var ResolutionUnitSpecifier;\n(function (ResolutionUnitSpecifier) {\n    /**\n     * Unit is unknown\n     */\n    ResolutionUnitSpecifier[ResolutionUnitSpecifier[\"UNKNOWN\"] = 0] = \"UNKNOWN\";\n    /**\n     * Unit is the metre\n     */\n    ResolutionUnitSpecifier[ResolutionUnitSpecifier[\"METRE\"] = 1] = \"METRE\";\n})(ResolutionUnitSpecifier || (ResolutionUnitSpecifier = {}));\n//# sourceMappingURL=types.js.map","import PngDecoder from './PngDecoder';\nimport PngEncoder from './PngEncoder';\nexport { hasPngSignature } from './helpers/signature';\nexport * from './types';\nfunction decodePng(data, options) {\n    const decoder = new PngDecoder(data, options);\n    return decoder.decode();\n}\nfunction encodePng(png, options) {\n    const encoder = new PngEncoder(png, options);\n    return encoder.encode();\n}\nfunction decodeApng(data, options) {\n    const decoder = new PngDecoder(data, options);\n    return decoder.decodeApng();\n}\nexport { decodePng as decode, encodePng as encode, decodeApng };\nexport { convertIndexedToRgb } from './convertIndexedToRgb';\n//# sourceMappingURL=index.js.map","import { IOBuffer } from 'iobuffer';\nimport { deflate } from 'pako';\nimport { writeCrc } from './helpers/crc';\nimport { writeSignature } from './helpers/signature';\nimport { encodetEXt } from './helpers/text';\nimport { InterlaceMethod, ColorType, CompressionMethod, FilterMethod, } from './internalTypes';\nconst defaultZlibOptions = {\n    level: 3,\n};\nexport default class PngEncoder extends IOBuffer {\n    _png;\n    _zlibOptions;\n    _colorType;\n    _interlaceMethod;\n    constructor(data, options = {}) {\n        super();\n        this._colorType = ColorType.UNKNOWN;\n        this._zlibOptions = { ...defaultZlibOptions, ...options.zlib };\n        this._png = this._checkData(data);\n        this._interlaceMethod =\n            (options.interlace === 'Adam7'\n                ? InterlaceMethod.ADAM7\n                : InterlaceMethod.NO_INTERLACE) ?? InterlaceMethod.NO_INTERLACE;\n        this.setBigEndian();\n    }\n    encode() {\n        writeSignature(this);\n        this.encodeIHDR();\n        if (this._png.palette) {\n            this.encodePLTE();\n            if (this._png.palette[0].length === 4) {\n                this.encodeTRNS();\n            }\n        }\n        this.encodeData();\n        if (this._png.text) {\n            for (const [keyword, text] of Object.entries(this._png.text)) {\n                encodetEXt(this, keyword, text);\n            }\n        }\n        this.encodeIEND();\n        return this.toArray();\n    }\n    // https://www.w3.org/TR/PNG/#11IHDR\n    encodeIHDR() {\n        this.writeUint32(13);\n        this.writeChars('IHDR');\n        this.writeUint32(this._png.width);\n        this.writeUint32(this._png.height);\n        this.writeByte(this._png.depth);\n        this.writeByte(this._colorType);\n        this.writeByte(CompressionMethod.DEFLATE);\n        this.writeByte(FilterMethod.ADAPTIVE);\n        this.writeByte(this._interlaceMethod);\n        writeCrc(this, 17);\n    }\n    // https://www.w3.org/TR/PNG/#11IEND\n    encodeIEND() {\n        this.writeUint32(0);\n        this.writeChars('IEND');\n        writeCrc(this, 4);\n    }\n    encodePLTE() {\n        const paletteLength = this._png.palette?.length * 3;\n        this.writeUint32(paletteLength);\n        this.writeChars('PLTE');\n        for (const color of this._png.palette) {\n            this.writeByte(color[0]);\n            this.writeByte(color[1]);\n            this.writeByte(color[2]);\n        }\n        writeCrc(this, 4 + paletteLength);\n    }\n    encodeTRNS() {\n        const alpha = this._png.palette.filter((color) => {\n            return color.at(-1) !== 255;\n        });\n        this.writeUint32(alpha.length);\n        this.writeChars('tRNS');\n        for (const el of alpha) {\n            this.writeByte(el.at(-1));\n        }\n        writeCrc(this, 4 + alpha.length);\n    }\n    // https://www.w3.org/TR/PNG/#11IDAT\n    encodeIDAT(data) {\n        this.writeUint32(data.length);\n        this.writeChars('IDAT');\n        this.writeBytes(data);\n        writeCrc(this, data.length + 4);\n    }\n    encodeData() {\n        const { width, height, channels, depth, data } = this._png;\n        const slotsPerLine = depth <= 8\n            ? Math.ceil((width * depth) / 8) * channels\n            : Math.ceil((((width * depth) / 8) * channels) / 2);\n        const newData = new IOBuffer().setBigEndian();\n        let offset = 0;\n        if (this._interlaceMethod === InterlaceMethod.NO_INTERLACE) {\n            for (let i = 0; i < height; i++) {\n                newData.writeByte(0); // no filter\n                if (depth === 16) {\n                    offset = writeDataUint16(data, newData, slotsPerLine, offset);\n                }\n                else {\n                    offset = writeDataBytes(data, newData, slotsPerLine, offset);\n                }\n            }\n        }\n        else if (this._interlaceMethod === InterlaceMethod.ADAM7) {\n            // Adam7 interlacing\n            offset = writeDataInterlaced(this._png, data, newData, offset);\n        }\n        const buffer = newData.toArray();\n        const compressed = deflate(buffer, this._zlibOptions);\n        this.encodeIDAT(compressed);\n    }\n    _checkData(data) {\n        const { colorType, channels, depth } = getColorType(data, data.palette);\n        const png = {\n            width: checkInteger(data.width, 'width'),\n            height: checkInteger(data.height, 'height'),\n            channels,\n            data: data.data,\n            depth,\n            text: data.text,\n            palette: data.palette,\n        };\n        this._colorType = colorType;\n        const expectedSize = depth < 8\n            ? Math.ceil((png.width * depth) / 8) * png.height * channels\n            : png.width * png.height * channels;\n        if (png.data.length !== expectedSize) {\n            throw new RangeError(`wrong data size. Found ${png.data.length}, expected ${expectedSize}`);\n        }\n        return png;\n    }\n}\nfunction checkInteger(value, name) {\n    if (Number.isInteger(value) && value > 0) {\n        return value;\n    }\n    throw new TypeError(`${name} must be a positive integer`);\n}\nfunction getColorType(data, palette) {\n    const { channels = 4, depth = 8 } = data;\n    if (channels !== 4 && channels !== 3 && channels !== 2 && channels !== 1) {\n        throw new RangeError(`unsupported number of channels: ${channels}`);\n    }\n    const returnValue = {\n        channels,\n        depth,\n        colorType: ColorType.UNKNOWN,\n    };\n    switch (channels) {\n        case 4:\n            returnValue.colorType = ColorType.TRUECOLOUR_ALPHA;\n            break;\n        case 3:\n            returnValue.colorType = ColorType.TRUECOLOUR;\n            break;\n        case 1:\n            if (palette) {\n                returnValue.colorType = ColorType.INDEXED_COLOUR;\n            }\n            else {\n                returnValue.colorType = ColorType.GREYSCALE;\n            }\n            break;\n        case 2:\n            returnValue.colorType = ColorType.GREYSCALE_ALPHA;\n            break;\n        default:\n            throw new Error('unsupported number of channels');\n    }\n    return returnValue;\n}\nfunction writeDataBytes(data, newData, slotsPerLine, offset) {\n    for (let j = 0; j < slotsPerLine; j++) {\n        newData.writeByte(data[offset++]);\n    }\n    return offset;\n}\nfunction writeDataInterlaced(imageData, data, newData, offset) {\n    const passes = [\n        { x: 0, y: 0, xStep: 8, yStep: 8 },\n        { x: 4, y: 0, xStep: 8, yStep: 8 },\n        { x: 0, y: 4, xStep: 4, yStep: 8 },\n        { x: 2, y: 0, xStep: 4, yStep: 4 },\n        { x: 0, y: 2, xStep: 2, yStep: 4 },\n        { x: 1, y: 0, xStep: 2, yStep: 2 },\n        { x: 0, y: 1, xStep: 1, yStep: 2 },\n    ];\n    const { width, height, channels, depth } = imageData;\n    let pixelSize = 0;\n    if (depth === 16) {\n        pixelSize = (channels * depth) / 8 / 2;\n    }\n    else {\n        pixelSize = (channels * depth) / 8;\n    }\n    // Process each pass\n    for (let passIndex = 0; passIndex < 7; passIndex++) {\n        const pass = passes[passIndex];\n        const passWidth = Math.floor((width - pass.x + pass.xStep - 1) / pass.xStep);\n        const passHeight = Math.floor((height - pass.y + pass.yStep - 1) / pass.yStep);\n        if (passWidth <= 0 || passHeight <= 0)\n            continue;\n        const passLineBytes = passWidth * pixelSize;\n        // For each scanline in this pass\n        for (let y = 0; y < passHeight; y++) {\n            const imageY = pass.y + y * pass.yStep;\n            // Extract raw scanline data\n            const rawScanline = depth <= 8\n                ? new Uint8Array(passLineBytes)\n                : new Uint16Array(passLineBytes);\n            let rawOffset = 0;\n            for (let x = 0; x < passWidth; x++) {\n                const imageX = pass.x + x * pass.xStep;\n                if (imageX < width && imageY < height) {\n                    const srcPos = (imageY * width + imageX) * pixelSize;\n                    for (let i = 0; i < pixelSize; i++) {\n                        rawScanline[rawOffset++] = data[srcPos + i];\n                    }\n                }\n            }\n            newData.writeByte(0); // no filter\n            if (depth === 8) {\n                newData.writeBytes(rawScanline);\n            }\n            else if (depth === 16) {\n                for (const value of rawScanline) {\n                    newData.writeByte((value >> 8) & 0xff); // High byte\n                    newData.writeByte(value & 0xff);\n                }\n            }\n        }\n    }\n    return offset;\n}\nfunction writeDataUint16(data, newData, slotsPerLine, offset) {\n    for (let j = 0; j < slotsPerLine; j++) {\n        newData.writeUint16(data[offset++]);\n    }\n    return offset;\n}\n//# sourceMappingURL=PngEncoder.js.map"],"names":["crcTable","n","c","k","initialCrc","checkCrc","buffer","crcLength","chunkName","expectedCrc","readUint32","actualCrc","data","Uint8Array","byteOffset","offset","currentCrc","length","updateCrc","Error","unfilterNone","currentLine","newLine","bytesPerLine","i","unfilterSub","bytesPerPixel","unfilterUp","prevLine","unfilterAverage","unfilterPaeth","paethPredictor","a","b","p","pa","Math","abs","pb","pc","applyUnfilter","filterType","passLineBytes","uint16","Uint16Array","osIsLittleEndian","swap16","val","empty","decodeInterlaceNull","params","width","height","channels","depth","ceil","newData","subarray","uint16Data","pngSignature","of","checkSignature","array","hasPngSignature","readBytes","latin1Decoder","TextDecoder","validateKeyword","keyword","text","latin1Regex","test","validateLatin1","readKeyword","mark","readByte","end","reset","decode","skip","IOBuffer","_checkCrc","_inflator","_png","_apng","_end","_hasPalette","_palette","_hasTransparency","_transparency","_compressionMethod","_filterMethod","_interlaceMethod","_colorType","_isAnimated","_numberOfFrames","_numberOfPlays","_frames","_writingDataChunks","constructor","options","super","this","numberOfFrames","numberOfPlays","frames","setBigEndian","type","readChars","decodeChunk","decodeImage","decodeApng","decodeApngChunk","decodeApngImage","decodeIHDR","decodePLTE","decodeIDAT","decodetRNS","decodeiCCP","readLatin1","decodetEXt","decodepHYs","pushDataToFrame","decodeACTL","decodeFCTL","decodeFDAT","image","value","checkBitDepth","readUint8","colorType","sequenceNumber","xOffset","yOffset","delayNumber","readUint16","delayDenominator","disposeOp","blendOp","push","RangeError","l","palette","dataLength","dataOffset","err","alpha","name","compressionMethod","compressedProfile","iccEmbeddedProfile","profile","ppuX","ppuY","unitSpecifier","resolution","x","y","unit","newFrame","frame","at","transparency","prevFrame","disposeFrame","addFrameDataToCanvas","imageFrame","row","col","index","channel","set","maxValue","calculatePixelIndices","frameIndex","sourceAlpha","foregroundValue","floor","result","passes","xStep","yStep","resultData","passIndex","pass","passWidth","passHeight","outputX","outputY","decodeInterlaceAdam7","lastFrame","ResolutionUnitSpecifier","decodePng"],"ignoreList":[],"sourceRoot":""}